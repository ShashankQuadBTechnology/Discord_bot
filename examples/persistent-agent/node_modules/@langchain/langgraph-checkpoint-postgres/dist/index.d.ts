import type { RunnableConfig } from "@langchain/core/runnables";
import { BaseCheckpointSaver, type Checkpoint, type CheckpointListOptions, type CheckpointTuple, type SerializerProtocol, type PendingWrite, type CheckpointMetadata, type ChannelVersions } from "@langchain/langgraph-checkpoint";
import pg from "pg";
interface PostgresSaverOptions {
    schema: string;
}
/**
 * LangGraph checkpointer that uses a Postgres instance as the backing store.
 * Uses the [node-postgres](https://node-postgres.com/) package internally
 * to connect to a Postgres instance.
 *
 * @example
 * ```
 * import { ChatOpenAI } from "@langchain/openai";
 * import { PostgresSaver } from "@langchain/langgraph-checkpoint-postgres";
 * import { createReactAgent } from "@langchain/langgraph/prebuilt";
 *
 * const checkpointer = PostgresSaver.fromConnString(
 *   "postgresql://user:password@localhost:5432/db",
 *   // optional configuration object
 *   {
 *     schema: "custom_schema" // defaults to "public"
 *   }
 * );
 *
 * // NOTE: you need to call .setup() the first time you're using your checkpointer
 * await checkpointer.setup();
 *
 * const graph = createReactAgent({
 *   tools: [getWeather],
 *   llm: new ChatOpenAI({
 *     model: "gpt-4o-mini",
 *   }),
 *   checkpointSaver: checkpointer,
 * });
 * const config = { configurable: { thread_id: "1" } };
 *
 * await graph.invoke({
 *   messages: [{
 *     role: "user",
 *     content: "what's the weather in sf"
 *   }],
 * }, config);
 * ```
 */
export declare class PostgresSaver extends BaseCheckpointSaver {
    private pool;
    private readonly options;
    private readonly SQL_STATEMENTS;
    protected isSetup: boolean;
    constructor(pool: pg.Pool, serde?: SerializerProtocol, options?: Partial<PostgresSaverOptions>);
    /**
     * Creates a new instance of PostgresSaver from a connection string.
     *
     * @param {string} connString - The connection string to connect to the Postgres database.
     * @param {PostgresSaverOptions} [options] - Optional configuration object.
     * @returns {PostgresSaver} A new instance of PostgresSaver.
     *
     * @example
     * const connString = "postgresql://user:password@localhost:5432/db";
     * const checkpointer = PostgresSaver.fromConnString(connString, {
     *  schema: "custom_schema" // defaults to "public"
     * });
     * await checkpointer.setup();
     */
    static fromConnString(connString: string, options?: Partial<PostgresSaverOptions>): PostgresSaver;
    /**
     * Set up the checkpoint database asynchronously.
     *
     * This method creates the necessary tables in the Postgres database if they don't
     * already exist and runs database migrations. It MUST be called directly by the user
     * the first time checkpointer is used.
     */
    setup(): Promise<void>;
    protected _loadCheckpoint(checkpoint: Omit<Checkpoint, "pending_sends" | "channel_values">, channelValues: [Uint8Array, Uint8Array, Uint8Array][], pendingSends: [Uint8Array, Uint8Array][]): Promise<Checkpoint>;
    protected _loadBlobs(blobValues: [Uint8Array, Uint8Array, Uint8Array][]): Promise<Record<string, unknown>>;
    protected _loadMetadata(metadata: Record<string, unknown>): Promise<any>;
    protected _loadWrites(writes: [Uint8Array, Uint8Array, Uint8Array, Uint8Array][]): Promise<[string, string, unknown][]>;
    protected _dumpBlobs(threadId: string, checkpointNs: string, values: Record<string, unknown>, versions: ChannelVersions): [string, string, string, string, string, Uint8Array | undefined][];
    protected _dumpCheckpoint(checkpoint: Checkpoint): Record<string, unknown>;
    protected _dumpMetadata(metadata: CheckpointMetadata): any;
    protected _dumpWrites(threadId: string, checkpointNs: string, checkpointId: string, taskId: string, writes: [string, unknown][]): [string, string, string, string, number, string, string, Uint8Array][];
    /**
     * Return WHERE clause predicates for a given list() config, filter, cursor.
     *
     * This method returns a tuple of a string and a tuple of values. The string
     * is the parameterized WHERE clause predicate (including the WHERE keyword):
     * "WHERE column1 = $1 AND column2 IS $2". The list of values contains the
     * values for each of the corresponding parameters.
     */
    protected _searchWhere(config?: RunnableConfig, filter?: Record<string, unknown>, before?: RunnableConfig): [string, unknown[]];
    /**
     * Get a checkpoint tuple from the database.
     * This method retrieves a checkpoint tuple from the Postgres database
     * based on the provided config. If the config's configurable field contains
     * a "checkpoint_id" key, the checkpoint with the matching thread_id and
     * namespace is retrieved. Otherwise, the latest checkpoint for the given
     * thread_id is retrieved.
     * @param config The config to use for retrieving the checkpoint.
     * @returns The retrieved checkpoint tuple, or undefined.
     */
    getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined>;
    /**
     * List checkpoints from the database.
     *
     * This method retrieves a list of checkpoint tuples from the Postgres database based
     * on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).
     */
    list(config: RunnableConfig, options?: CheckpointListOptions): AsyncGenerator<CheckpointTuple>;
    /**
     * Save a checkpoint to the database.
     *
     * This method saves a checkpoint to the Postgres database. The checkpoint is associated
     * with the provided config and its parent config (if any).
     * @param config
     * @param checkpoint
     * @param metadata
     * @returns
     */
    put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, newVersions: ChannelVersions): Promise<RunnableConfig>;
    /**
     * Store intermediate writes linked to a checkpoint.
     *
     * This method saves intermediate writes associated with a checkpoint to the Postgres database.
     * @param config Configuration of the related checkpoint.
     * @param writes List of writes to store.
     * @param taskId Identifier for the task creating the writes.
     */
    putWrites(config: RunnableConfig, writes: PendingWrite[], taskId: string): Promise<void>;
    end(): Promise<void>;
}
export {};
